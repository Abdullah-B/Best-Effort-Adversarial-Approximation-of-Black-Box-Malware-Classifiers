import os.path, math, string, sys
sys.path.append('F:\\ember-master\\ember-master\\malconv')
sys.path.append('F:\\ember-master\\ember-master\\malconv\\scurve')
sys.path.append('F:\\ember-master\\ember-master\\malconv\\cairo')
# sys.path.append( '.' )
# sys.path.append( '../imports' )
# sys.path.append( '../imports/cairo' )
# sys.path.append( '../imports/scurve' )
import scurve
from scurve import progress, utils, draw
from PIL import Image, ImageDraw
import numpy as np
import matplotlib.pyplot as plt
import pickle
from sklearn import preprocessing
from sklearn.utils import shuffle
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.contrib.layers import flatten
import pandas as pd
import cv2
from os import path

class _Color:
    def __init__(self, data, block):
        self.data, self.block = data, block
        s = list(set(data))
        s.sort()
        self.symbol_map = {v : i for (i, v) in enumerate(s)}

    def __len__(self):
        return len(self.data)

    def point(self, x):
        if self.block and (self.block[0]<=x<self.block[1]):
            return self.block[2]
        else:
            return self.getPoint(x)


class ColorGradient(_Color):
    def getPoint(self, x):
        c = ord(self.data[x])/255.0
        return [
            int(255*c),
            int(255*c),
            int(255*c)
        ]


class ColorHilbert(_Color):
    def __init__(self, data, block):
        _Color.__init__(self, data, block)
        self.csource = scurve.fromSize("hilbert", 3, 256**3)
        self.step = len(self.csource)/float(len(self.symbol_map))

    def getPoint(self, x):
        c = self.symbol_map[self.data[x]]
        return self.csource.point(int(c*self.step))


class ColorClass(_Color):
    def getPoint(self, x):
        c = self.data[x]
        if c == 0:
            return [0, 0, 0]
        elif c == 255:
            return [255, 255, 255]
        elif chr(c) in string.printable:
            return [55, 126, 184]
        return [228, 26, 28]


class ColorEntropy(_Color):
    def getPoint(self, x):
        e = utils.entropy(self.data, 32, x, len(self.symbol_map))
        # http://www.wolframalpha.com/input/?i=plot+%284%28x-0.5%29-4%28x-0.5%29**2%29**4+from+0.5+to+1
        def curve(v):
            f = (4*v - 4*v**2)**4
            f = max(f, 0)
            return f
        r = curve(e-0.5) if e > 0.5 else 0
        b = e**2
        return [
            int(255*r),
            0,
            int(255*b)
        ]


def drawmap_unrolled(map, size, csource, name):
    map = scurve.fromSize(map, 2, size**2)
    c = Image.new("RGB", (size, size*4))
    cd = ImageDraw.Draw(c)
    step = len(csource)/float(len(map)*4)

    for quad in range(4):
        for i, p in enumerate(map):
            off = (i + (quad * size**2))
            color = csource.point(int(off * step))
            x, y = tuple(p)
            cd.point((x, y + (size * quad)),fill=tuple(color))
    c.save(name)


def drawmap_square(map, size, csource, name):
    map = scurve.fromSize(map, 2, size**2)
    c = Image.new("RGB", map.dimensions())
    cd = ImageDraw.Draw(c)
    step = len(csource)/float(len(map))
    for i, p in enumerate(map):
        color = csource.point(int(i*step))
        cd.point(tuple(p), fill=tuple(color))
    c.save(name)


def binvisBenign():
    
    train_labelsM = pd.read_csv('F:/DataCollection2/IMG_M.csv', index_col=False) #FileNames_revised.csv

    
    hashes = train_labelsM['FileName'].tolist()
    labels = train_labelsM['Predicted'].tolist()
    zipped = list(zip(hashes, labels))
    
    
    nbr =0
    
    print("Processing:")

    for sha256,l in zipped:
        if l == 0:
            labell= 'Benign_'
        else:
            labell= 'Malware_'
        
        
        if nbr ==1000:
            break
   
        #dst = sha256.replace('.exe', '')
        dst = sha256.replace(':/DataCollection2/Malware/','')
        if path.exists('I:/InceptionV3DataEN/BenignEnt/'+labell+dst+'.png') or path.exists('I:/InceptionV3DataEN/MalwareEnt/'+labell+dst+'.png'):
            print('***')
            continue
        try:   
        # dst = "I:/Benign/Output/" + dst + ".png"
            with open(sha256, "rb") as f:
                binFile = f.read()
            block = None
            csource = ColorEntropy(binFile, block)
            drawmap_square("hilbert", 256, csource, 'I:/InceptionV3DataEN/MalwareEnt/'+labell+dst+'.png')
            nbr+=1
        except:
            print('failed?')

        
        
        
        
    print("")
    print("..Done..")



binvisBenign()

#





    