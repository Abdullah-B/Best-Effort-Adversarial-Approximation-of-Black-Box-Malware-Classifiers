import os.path, math, string, sys
sys.path.append('F:\\ember-master\\ember-master\\malconv')
sys.path.append('F:\\ember-master\\ember-master\\malconv\\scurve')
sys.path.append('F:\\ember-master\\ember-master\\malconv\\cairo')
# sys.path.append( '.' )
# sys.path.append( '../imports' )
# sys.path.append( '../imports/cairo' )
# sys.path.append( '../imports/scurve' )
import scurve
from scurve import progress, utils, draw
from PIL import Image, ImageDraw
import numpy as np
import matplotlib.pyplot as plt
import pickle
from sklearn import preprocessing
from sklearn.utils import shuffle
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.contrib.layers import flatten
import pandas as pd
import cv2
from os import path

class _Color:
    def __init__(self, data, block):
        self.data, self.block = data, block
        s = list(set(data))
        s.sort()
        self.symbol_map = {v : i for (i, v) in enumerate(s)}

    def __len__(self):
        return len(self.data)

    def point(self, x):
        if self.block and (self.block[0]<=x<self.block[1]):
            return self.block[2]
        else:
            return self.getPoint(x)


class ColorGradient(_Color):
    def getPoint(self, x):
        c = ord(self.data[x])/255.0
        return [
            int(255*c),
            int(255*c),
            int(255*c)
        ]


class ColorHilbert(_Color):
    def __init__(self, data, block):
        _Color.__init__(self, data, block)
        self.csource = scurve.fromSize("hilbert", 3, 256**3)
        self.step = len(self.csource)/float(len(self.symbol_map))

    def getPoint(self, x):
        c = self.symbol_map[self.data[x]]
        return self.csource.point(int(c*self.step))


class ColorClass(_Color):
    def getPoint(self, x):
        c = self.data[x]
        if c == 0:
            return [0, 0, 0]
        elif c == 255:
            return [255, 255, 255]
        elif chr(c) in string.printable:
            return [55, 126, 184]
        return [228, 26, 28]


class ColorEntropy(_Color):
    def getPoint(self, x):
        e = utils.entropy(self.data, 32, x, len(self.symbol_map))
        # http://www.wolframalpha.com/input/?i=plot+%284%28x-0.5%29-4%28x-0.5%29**2%29**4+from+0.5+to+1
        def curve(v):
            f = (4*v - 4*v**2)**4
            f = max(f, 0)
            return f
        r = curve(e-0.5) if e > 0.5 else 0
        b = e**2
        return [
            int(255*r),
            0,
            int(255*b)
        ]


def drawmap_unrolled(map, size, csource, name):
    map = scurve.fromSize(map, 2, size**2)
    c = Image.new("RGB", (size, size*4))
    cd = ImageDraw.Draw(c)
    step = len(csource)/float(len(map)*4)

    for quad in range(4):
        for i, p in enumerate(map):
            off = (i + (quad * size**2))
            color = csource.point(int(off * step))
            x, y = tuple(p)
            cd.point((x, y + (size * quad)),fill=tuple(color))
    c.save(name)


def drawmap_square(map, size, csource, name):
    map = scurve.fromSize(map, 2, size**2)
    c = Image.new("RGB", map.dimensions())
    cd = ImageDraw.Draw(c)
    step = len(csource)/float(len(map))
    for i, p in enumerate(map):
        color = csource.point(int(i*step))
        cd.point(tuple(p), fill=tuple(color))
    c.save(name)


def binvisBenign():
    fc = 0
    train_labelsM = pd.read_csv('Tables/TrainingSet_Aprox.csv', index_col=False, skiprows=15583) #use the name of the file with the needed data for inception ( this is used for the training of the model and testing as well)######################

    
    hashes = train_labelsM.iloc[:,0].tolist()
    labels = train_labelsM.iloc[:,2].tolist()
    zipped = list(zip(hashes, labels))
    
    
    
    
    print("Processing:")

    for sha256,l in zipped:
        if fc>2000:
            break
        if l == 0:
            labell= 'Benign_'
            
        else:
            labell ='Malware_'
        if "Benign" in sha256 :
            dst = sha256.replace('I:/BenignData/DataCollection/','')
            sub = "/Benign/"

        else :
            dst = sha256.replace(':/DataCollection2/Malware/','')
            sub = "/Malware/"

        #dst = sha256.replace('.exe', '')
        
        # if path.exists('I:/InceptionV3DataEN_8K/Benign/'+labell+dst+'.png') or path.exists('I:/TestEN/'+labell+dst+'.png') or path.exists('I:/InceptionV3DataEN_8K/Malware/'+labell+dst+'.png'):
        #     print('***')
        #     continue
        try:   
        # dst = "I:/Benign/Output/" + dst + ".png"ColorHilbert
            with open(sha256, "rb") as f:
                binFile = f.read()
                print('here')
            block = None
            csource = ColorEntropy(binFile, block)
            drawmap_square("hilbert", 256, csource, 'I:/Type_EN/'+sub+labell+dst+'.png')
            csource = ColorHilbert(binFile, block)
            drawmap_square("hilbert", 256, csource, 'I:/Type_CH/'+sub+labell+dst+'.png')
            fc=1
            print(fv)
        except:
            print('failed?')

        
        
        
        
    print("")
    print("..Done..")



binvisBenign()

# python InceptionModel.py --image_dir I:/InceptionV3DataCH_2K //Done
# python InceptionModel.py --image_dir I:/InceptionV3DataCH_4K //Done
# python InceptionModel.py --image_dir I:/InceptionV3DataCH_6K //Done
# python InceptionModel.py --image_dir I:/InceptionV3DataCH_8K //Done
# python InceptionModel.py --image_dir G:/DataCollection2/InceptionV3DataFlip //16K Done //24K Done
# python InceptionModel.py --image_dir G:/DataCollection2/InceptionV3DataFlip_EN //16K Done //24K Done



# tensorboard --logdir /tmp_2K_CH/retrain_logs //Done
# tensorboard --logdir /tmp_4K_CH/retrain_logs //Done
# tensorboard --logdir /tmp_6K_CH/retrain_logs //Done
# tensorboard --logdir /tmp_8K_CH/retrain_logs //Done
# tensorboard --logdir /tmp_2K_EN/retrain_logs //Done
# tensorboard --logdir /tmp_4K_EN/retrain_logs //Done
# tensorboard --logdir /tmp_6K_EN/retrain_logs 
# tensorboard --logdir /tmp_8K_EN/retrain_logs 
# tensorboard --logdir /tmp_16K_Flipped_CH/retrain_logs 
# tensorboard --logdir /tmp_16K_Flipped_EN/retrain_logs 
# tensorboard --logdir /tmp_24K_FR_CH/retrain_logs 
# tensorboard --logdir /tmp_24K_FR_EN/retrain_logs 



    